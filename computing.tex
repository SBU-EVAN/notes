\subsection{Markov Chain Monte Carlo (MCMC)} 
Interestingly, MCMC algorithms have heavy analogies with statistical mechanics which are useful to demonstrate the concept. To examine this, lets first define what a Markov Chain is.
\begin{defn}
A sequence $X_1,\hdots,X_n$ of random elements is a \textit{Markov Chain} if the conditional distribution $X_{n+1}$ depends only on $X_n$. The set in which $X_i$ take values is called the \textit{state space} of the chain.
\end{defn}


\subsection{The Metropolis-Hastings Algorithm}
Suppose we want to sample from a distribution $p(x)$. $p(x)$ can be high dimensional and is generally difficult to calculate (evidence is hard to compute since it requires integration over the entire parameter space). The goal is to use Markov Chains to sample from $p(x)$ without needing to compute the evidence. This will be represented as a path through state space until the chain reaches a stable point (stationary state).

We start with a proposal distribution $g(x_n)$. Sample from the proposal distribution to find the next state $x_{n+1}$ with probability $g(x_{n+1}|x_n)$. This transition from state $n$ to state $n+1$ must follow the \textit{detailed balance condition}
\[ p(x_n) g(x_{n+1}|x_n) A(x_n \rightarrow x_{n+1}) = p(x_{n+1}) g(x_n|x_{n+1}) A(x_{n+1} \rightarrow x_{n}) \]
where $A$ is an \textit{acceptance probability} which I will define more precisely later. Using Bayes' Theorem on $p(x)$, the evidence cancels out on each side, and thus the detailed balance condition can be simplified to only rely on the likelihood and prior of $p(x)$, which I will denote $\pi$ and $\mathcal{L}$.
\[ \pi(x_n)\mathcal{L}(x_n) g(x_{n+1}|x_n) A(x_n \rightarrow x_{n+1}) = \pi(x_{n+1}) \mathcal{L}(x_{n+1}) g(x_{n}|x_{n+1}) A(x_{n+1}\rightarrow x_{n}) \]
\[ \Rightarrow \frac{A(x_n \rightarrow x_{n+1})}{A(x_{n+1}\rightarrow x_{n})} = \frac{\pi(x_{n+1}) \mathcal{L}(x_{n+1}) g(x_{n}|x_{n+1})}{\pi(x_n)\mathcal{L}(x_n) g(x_{n+1}|x_n)} \equiv R_{n,n+1} \]
This allows us to define the acceptance probability as
\[ A(x_n \rightarrow x_{n+1}) = \min( 1, R_{n,n+1} ) \]
This probability is used to determine whether the chain moves to $x_{n+1}$ or stays at $x_n$. The chain converges when it reaches a stationary state.

There are a few properties that can be observed for this algorithm:
\begin{itemize}
    \item Having an asymmetrical proposal $g(x)$ can allow for faster convergence of the chain.
    \item The initial sampling may not accurately reflect samples for $p(x)$. This is regarded as the `burn-in' and is generally discarded from the samples.
    \item MCMC Sampling loses sampling power for multi-modal distributions. 
\end{itemize}

\subsection{Parameter Difference Distribution}
Define the posterior probability of parameters $\theta$ within model $\mathcal{M}$ given data $d$ as (Bayes' theorem)
\begin{equation}
    \mathcal{P}(\theta) := P(\theta|d,\mathcal{M}) = \frac{P(\theta|\mathcal{M})P(d|\theta,\mathcal{M})}{P(d|\mathcal{M})}
\end{equation}
The following notation will simplify this expression
\begin{equation*}
    \begin{split}
        \Pi(\theta) &= P(\theta|\mathcal{M}) \text{, Prior probability} \\
        \mathcal{L}(\theta) &= P(d|\theta,\mathcal{M}) \text{, the likelihood} \\
        \mathcal{E} &= P(d|\mathcal{M}) \text{, the evidence}
    \end{split}
\end{equation*}
\[ \mathcal{P}(\theta) := P(\theta|d,\mathcal{M}) = \frac{\Pi(\theta)\mathcal{L}}{\mathcal{E}} \]
These are (maybe?) understandable as the prior probability is the parameters given the model, the likelihood as the data given some parameters of the model, and the evidence as the data give a model. From now on, the model $\mathcal{M}$ will be implied.

Consider now two data sets $d_1,d_2$. They have a joint likelihood 
\[ \mathcal{L}(\theta) = P(d_1,d_2|\theta) \]
This \textbf{quantifies the likelihood of $d_1$ and $d_2$ coming from the same set of parameters of a given model.} Denote now $\mathcal{L}_1,\mathcal{P}_1$ as the marginalized likelihood and Posterior over $d_2$. (\textbf{Is there a procedure/algorithm to find the marginalized probability? Seems generally non-trivial}).

Now duplicate the parameter set to $\theta_1,\theta_2$ and perscibe a new joint likelihood $\mathcal{L}(\theta_1,\theta_2) = P(d_1,d_2|\theta_1,\theta_2)$. \textbf{This is generally a choice, but how can one make a good choice?} The choice however is not unique.

As such, the constraints are imposed:
\begin{enumerate}
    \item $\mathcal{L}(\theta_1=\theta,\theta_2=\theta) = \mathcal{L}(\theta)$, or in plain english, the joint likelihood if $\theta_1=\theta=\theta_2$ needs to coincide with the likelihood of $\theta$
    \item $P(d_1|\theta_1,\theta_2)=P(d_1|\theta_1)$ once marginalized over $d_2$. Marginalizing the likelihood over one of the data sets removes the dependancy on the corresponding parameter sets.
\end{enumerate}
 \textbf{This ensures the datasets are conditionally independent,}
\[ P(d_1,d_2|\theta) = P(d_1|\theta)P(d_2|\theta) \]
\textbf{Proof?}
Which means we can choose 
\[ \mathcal{L}(\theta_1,\theta_2) = \mathcal{L}_1(\theta_1)\mathcal{L}_2(\theta_2) \]
If we further assume the prior distribution can be factorized, the joint posterior is then
\[ \mathcal{P}(\theta_1,\theta_2) = \mathcal{L}(\theta_1,\theta_2)\Pi(\theta_1)\Pi(\theta_2) \]
Defining $\Delta\theta = \theta_1-\theta_2$, the parameter difference posterior is given by
\[ \mathcal{P}(\Delta\theta) = \int_{V_\Pi} \mathcal{P}(\theta,\theta-\Delta\theta)d\theta\]

\subsection{Quantifying Results}

Given some probability $P$ of a parameter shift, the following formula can give you the number of standard deviations if the probability shift comes from a gaussian distribution
\[ n_\sigma = \sqrt{2} \text{Erf}^{-1}(P) \]
I have a notebook using two unit gaussian priors separated by a distance $a$. This example can be computed analytically.
\begin{equation*}
    \begin{split}
	\mathcal{P}(\Delta \theta) &= \frac{1}{2\pi} \int\limits_{-\infty}^{\infty} e^{-\theta^2/2} e^{-{(\theta-\Delta\theta)}^2/2}  d\theta \\
				   &= \frac{1}{2\pi} \cdot \sqrt{\pi} e^{-{(\Delta\theta)}^2/4}\\
				   &= \frac{1}{\sqrt{4\pi}}e^{-{(\Delta\theta)}^2/4}\\
    \end{split}
\end{equation*}
The parameter difference posterior is a gaussian with standard deviation $\sqrt{2}$. The separation is fixed by $a$, hence the shift is $\mathcal{P}(a)$. Hence the shift probability is
\[ \Delta = \int\limits_{-a}^{a} e^{-{(\Delta\theta)}^2/4} d\Delta\theta \]
Lets use the example $a=2$. Then $n_\sigma = 2/\sqrt{2} = \sqrt{2}$. Using this we can work backwards to find $\Delta$ from a $z$-table to find $\Delta = 0.9207 - 0.0793 = 0.8414 $. 

\subsection{Normalizing Flows}
The method of normalizing flows (MAF) implemented here uses Masked Autoencoders (MADE) to construct the flow. Suppose we have an input to the flow $x_i$. The output of the map is $y_i= \mu(x_{1:i-1})+\sigma(x_{1:i-1})x_i$. The $\mu$ and $\sigma$ are found using neural networks which recieve masked inputs $x_{1:i-1}=(x_1,\ldots,x_{i-1},0,\ldots,0)$. Since the input only depends on the first $i-1$ inputs, the normalizing flow is \textit{autoregressive} and the Jacobian is triangular.

The implementation in tensorflow uses \textit{bijectors} which implements a local diffeomorphism between a manifold $M$ and a target manifold $N$ (which are our parameter spaces), i.e. $\phi:M\rightarrow N$ such that $\phi$ is differentiable and injective. In tensorflow it has three operations, Forward, Inverse, and log\_deg\_jacobian, which are exactly the three we want. By constructing a bijector for each masked input, the full normalizing map can be constructed.

\bigskip
\hrule
\textbf{\large References}

\url{https://www.colorado.edu/amath/sites/default/files/attached-files/2_28_2018.pdf}

\url{https://si.biostat.washington.edu/sites/default/files/modules/Geyer-Introduction\%20to\%20markov\%20chain\%20Monte\%20Carlo_0.pdf}

\url{https://towardsdatascience.com/monte-carlo-markov-chain-mcmc-explained-94e3a6c8de11}

\url{https://www.sheffield.ac.uk/polopoly_fs/1.60510!/file/MCMC.pdf}
\hrule

Test graph

  \begin{tikzpicture}

    \pgfplotsset{
      scale only axis,
    }

    \begin{axis}[
      xlabel=$x$,
      ylabel=$y$,
      samples=100,
      ]
      \addplot[][domain=-4.5:4]{0.2*x^3-x+1};
      \addplot[draw=red][domain=-4.5:4]{3*sin(deg(x))};
    \end{axis}

  \end{tikzpicture}
